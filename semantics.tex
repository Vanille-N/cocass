\input{header.tex}

\newcommand{\Cmp}{\(\pm\)C)}
\newcommand{\Cmm}{C\textminus\textminus}
\newcommand{\fun}{\text{fun}_\pi^n}
\newcommand{\fnptr}{\text{fun}_\mu^n}
\newcommand{\gives}{\vdash_\pi}

\title{Semantics of \Cmp (i.e. extended \Cmm)}
\author{\textsc{Villani} Neven, ENS Paris-Saclay\\\textsc{Programmation 1 -- Compilateur COCass}}

\begin{document}
\maketitle

Retranscribed and extended from \url{http://www.lsv.fr/~goubault/CoursProgrammation/minic.html}\\
and \url{http://www.lsv.fr/~goubault/CoursProgrammation/prog1_sem1.pdf}.\\


\section{Expressions}

\subsection*{Notation}

\(\ZZ_{64}\triangleq \ZZ/64\ZZ\) is the set in which all calculations are done.\\

We write \((\rho: \mathcal{S}\to\ZZ_{64})\in \mathcal{P}\) the environment, where \(\mathcal{S}\) is the set of names of variables and functions, \((\mu: \ZZ_{64}\to\ZZ_{64})\in \mathcal{M}\) the memory.\\

A flag is defined as an element of \(\mathcal{E} \triangleq S \sqcup \{ \t{brk}, \t{ret}, \t{cnt}, \t{nil} \}\).\\
Intuitively, \(\rho,\mu,\chi,v \Vdash_\pi c \tto \rho',\mu',\chi',v'\) means that when \(c\) is executed under the environment \(\rho\) with the memory \(\mu\), the flag \(\chi\), and the previous value \(v\), it updates it to the new environment and memory \(\rho'\) and \(\mu'\), raises \(\chi'\), and changes the value to \(v'\).\\

In addition, we write \(\fun: \mathcal{S}\to \mathcal{F}^n\) where \(\mathcal{F}^n \triangleq (\mathcal{M} \times \mathcal{E} \times \ZZ_{64})^{\mathcal{P} \times \mathcal{M} \times \ZZ_{64}^n}\), i.e. functions that take an environment, a memory layout and \(n\) 64-bit integer arguments and return one 64-bit integer, the updated memory, and a flag.\\
\(\fnptr: \ZZ_{64}\to \mathcal{F}^n\) returns the function (if there is one) defined at the given memory address, and is useful for variables that are function pointers.\\

For \(\mu\in\mathcal{M}, v\in\ZZ_{64}, x\in\ZZ_{64}\) we write \(\mu[x\mapsto v]: \left\{\begin{array}{ll}x\mapsto v & \\ y\mapsto \mu(y) & y\in \dom\mu\setminus\{x\}\end{array}\right.\)
For local and global variables:
\[\dfrac{x\in\dom\rho \qquad \rho(x)\in\dom\mu}{\envyields \t{VAR}\ x\tto \mu(\rho(x)), \mu}\]
i.e. reading a variable returns its contents and changes nothing to the memory.\\

For constant integers:
\[\dfrac{}{\envyields \t{CST}\ n\tto n, \mu}\]

For strings:
\[\dfrac{s\text{ stored at }a\in Addr}{\envyields \t{STRING}\ s\tto a, \mu}\]

For arrays:
\[\dfrac{t\in\dom\rho \qquad \envyields e\tto i,\mu' \qquad (\rho(t)+i\times 8)\modsize\in\dom\mu}{\envyields \t{OP2}(\t{S\_INDEX}, t, e) \tto \mu'(\rho(t)+i\times 8 \modsize)}\]

None of these are different from the original \Cmm semantics.

\subsection{Unary operators without side-effects}
Unary minus (same as \Cmm):
\[\dfrac{\envyields e \tto v,\mu'}{\envyields \t{OP1}(\t{M\_MINUS}, e) \tto -v \modsize,\mu'}\]

Unary bitwise negation (same as \Cmm):
\[\dfrac{\envyields e\tto v,\mu'}{\envyields \t{OP1}(\t{M\_NOT}, e) \tto -v-1 \modsize,\mu'}\]

Indirection (added in \Cpm):
\[\dfrac{x\in\dom\rho}{\envyields \t{OP1}(\t{M\_ADDR}, x)\tto \rho(x),\mu}\]
\[\dfrac{x\in\dom\rho \qquad \envyields e\tto v,\mu'}{\envyields \t{OP1}(\t{M\_ADDR}, \t{OP2}(\t{S\_INDEX}, x, e)) \tto (\rho(x)+v\times 8) \modsize, \mu'}\]
\[\dfrac{\envyields e\tto v,\mu'}{\envyields \t{OP1}(\t{M\_ADDR}, \t{OP1}(\t{M\_DEREF}, e)) \tto v,\mu'}\]

Dereferencing (added in \Cpm):
\[\dfrac{\envyields e\tto v,\mu' \qquad v\in\dom\mu'}{\envyields \t{OP1}(\t{M\_DEREF}, e) \tto \mu'(v),\mu'}\]

\subsection{Binary operators without side-effects}
Multiplication (same as \Cmm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_MUL}, e_1, e_2) \tto v_1\times v_2\modsize,\mu''}\]

Addition (same as \Cmm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_ADD}, e_1, e_2) \tto v_1 + v_2\modsize,\mu''}\]

Subtraction (same as \Cmm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_SUB}, e_1, e_2) \tto v_1 - v_2\modsize,\mu''}\]

Division and remainder (same as \Cmm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_DIV}, e_1, e_2) \tto v_1 \div v_2,\mu''}\]
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_MOD}, e_1, e_2) \tto v_1 \mod v_2,\mu''}\]
Since \(v_1 \div v_2\) and \(v_1 \mod v_2\) are sure to be in the correct range, there is no need to specify they are taken \(\modsize\).

Shifts (added in \Cpm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_SHL}, e_1, e_2) \tto v_1 \times 2^{v_2} \modsize}\]
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_SHL}, e_1, e_2) \tto v_1 \div 2^{v_2} \modsize}\]



Let \(\dec: \{ \bot, \top \}^{64} \to \ZZ_{64}\) the function
\[(b_0, \cdots, b_{63}) \mapsto \sum_{i=0}^{63} (1\t{ if } b_i\t{ else }0)\times 2^i\]
and \(\bin = \dec^{-1}\).

We can now define bitwise operators as follows (added in \Cpm).\\
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu'' \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1) \qquad (b_0^2,\cdots,b_{63}^2) = \bin(v_2)}{\envyields \t{OP2}(\t{S\_AND}, e_1, e_2) \tto \dec(b_0^1 \wedge b_0^2,\cdots, b_{63}^1 \wedge b_{63}^2)}\]
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu'' \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1) \qquad (b_0^2,\cdots,b_{63}^2) = \bin(v_2)}{\envyields \t{OP2}(\t{S\_OR}, e_1, e_2) \tto \dec(b_0^1 \vee b_0^2,\cdots, b_{63}^1 \vee b_{63}^2)}\]
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu'' \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1) \qquad (b_0^2,\cdots,b_{63}^2) = \bin(v_2)}{\envyields \t{OP2}(\t{S\_XOR}, e_1, e_2) \tto \dec(b_0^1 \oplus b_0^2,\cdots, b_{63}^1 \oplus b_{63}^2)}\]


\end{document}
