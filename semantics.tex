\input{header.tex}

\newcommand{\Cmp}{\(\pm\)C}
\newcommand{\Cmm}{C\textminus\textminus}
\newcommand{\fun}{\text{fun}_\pi}
\newcommand{\fnptr}{\text{fun}_\mu^n}
\newcommand{\gives}{\vdash_\pi}
\newcommand{\brk}{\t{brk}}
\newcommand{\ret}{\t{ret}}
\newcommand{\cnt}{\t{cnt}}
\newcommand{\nil}{\t{nil}}

\title{Semantics of \Cmp (i.e. extended \Cmm)}
\author{\textsc{Villani} Neven, ENS Paris-Saclay\\\textsc{Programmation 1 -- Compilateur COCass}}

\begin{document}
\maketitle

Retranscribed and extended from \url{http://www.lsv.fr/~goubault/CoursProgrammation/minic.html}\\
and \url{http://www.lsv.fr/~goubault/CoursProgrammation/prog1_sem1.pdf}.\\


\section*{Notation}

\(\ZZ_{64}\) is the set of 64-bit signed integers, in which all calculations are done when not specified otherwise.\\

We write \((\rho: \mathcal{S}\to\ZZ_{64})\in \mathcal{P}\) the environment, where \(\mathcal{S}\) is the set of names of variables and functions, \((\mu: \ZZ_{64}\to\ZZ_{8})\in \mathcal{M}\) the memory.\\
\(\mu\) is read by blocks of 8 bytes : \(\mu^{64}(i) \triangleq \sum_{k=0}^7 2^{8k}\mu(i+k)\).\\
\(\rho_g\in\mathcal{P}\) is the global environment.\\

A flag is defined as an element of \(\mathcal{E} \triangleq S \sqcup \{ \brk, \ret, \cnt, \nil \}\): either an exception string or a special control flow keyword.\\
Intuitively, \(\rho,\mu,\chi,v \gives c \tto \rho',\mu',\chi',v'\) means that when \(c\) is executed under the environment \(\rho\) with the memory \(\mu\), the flag \(\chi\), and the previous value \(v\), it updates it to the new environment and memory \(\rho'\) and \(\mu'\), raises \(\chi'\), and changes the value to \(v'\). Variants are used for toplevel declarations (no \(\chi\) nor \(v\) but \(\fun\) is added), and expressions (\(\rho\) is never modified and thus does not appear on the right side)\\

In addition, we write \(\fun: \ZZ_{64}\to \t{code}\), a wrapper around \Cmp\ functions: \(\fun(a)(p_1, \cdots, p_n) = c\) updates the environment with \(p_1, \cdots, p_n\) and executes the body of the function whose definition was given by the code \(c\) and stored at \(a\). This way of considering functions allows in particular for function pointers.\\

For \(\mu\in\mathcal{M}, v\in\ZZ_{8}, x\in\ZZ_{64}\) we write \(\mu[x\mapsto v]: \left\{\begin{array}{ll}x\mapsto v & \\ y\mapsto \mu(y) & y\in \dom\mu\setminus\{x\}\end{array}\right.\)\\
However we will usually use \(\mu^{64}[x\mapsto v] \triangleq\mu[x+k\mapsto v_k\ |\  0\leq k<8,\ v = \sum_{k=0}^8 2^{8k}v_k]\), i.e. the memory is written 8 bytes at a time.\\

A similar notation is used for \(\rho\), \(\rho_g\) and \(\fun\).

\(alloc^i: \mathcal{M}\to \mathcal{P}(\ZZ_{64})\) is such that if \(k \in alloc^i(\mu) \ne \bot\) then \(\forall 0\leq j < i, k+j\not\in\dom\mu\).

The domains as well are ommitted : "\(\rho\in P\)", "\(\mu\in\mathcal{M}\)", etc. are not explicit.

\section{Expressions}
\subsection{Reading values}
For local and global variables:
\[\dfrac{x\in\dom\rho \qquad \rho(x)\in\dom\mu}{\rho,\mu,\nil,v \gives^e \t{VAR}\ x\tto \mu,\nil,\mu^{64}(\rho(x))}\rule{Var}{}\]
i.e. reading a variable returns its contents and changes nothing to the memory.\\
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives^e \t{VAR}\ x\tto \mu,\chi,v} \rule{Var}{^\chi}\]

For constant integers:
\[\dfrac{}{\rho,\mu,\nil,v \gives^e \t{CST}\ n\tto \mu,\nil,n}\rule{Cst}{}\]
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives^e \t{CST}\ n\tto \mu,\chi,v} \rule{Cst}{^\chi}\]

For strings:
\[\dfrac{s\text{ stored at }a\in Addr}{\rho,\mu,\nil,v \gives^e \t{STRING}\ s\tto \mu,\nil,a}\rule{Str}{}\]
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives^e \t{STRING}\ s\tto \mu,\chi,v} \rule{Cst}{^\chi}\]

For arrays:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e i\tto \mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,i \gives^e a\tto \mu_a,\nil,v_a \\
    v_a+v_i\times 8\in\dom\mu_a
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_INDEX}, a, i) \tto \mu_a,\nil,\mu_a^{64}(v_a+v_i\times 8)}\rule{Idx}{}\]

None of these are different from the original \Cmm\ semantics.

\subsection{Unary operators without side-effects}
Unary minus (same as \Cmm):
\[\dfrac{
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e
}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_MINUS}, e) \tto \mu_e,\nil,-v_e}\rule{Neg}{}\]

Unary bitwise negation (same as \Cmm):
\[\dfrac{
    \rho,\mu,\chi,v \gives^e e\tto \mu_e,\nil,v_e
}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_NOT}, e) \tto \mu_e,\nil,-v_e-1}\rule{Not}{}\]


Indirection (added in \Cmp):
\[\dfrac{
    x\in\dom\rho
}{\rho,\mu,\nil,v \gives^e \t{OP1}(\t{M\_ADDR}, \t{VAR}\ x)\tto \mu,\nil,\rho(x)}\rule{Var}{^\&}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e i\tto \mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives^e a\tto \mu_a,\nil,v_a \\
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_ADDR}, \t{OP2}(\t{S\_INDEX}, a, i)) \tto \mu_a,\nil,v_a+v_i\times 8}\rule{Idx}{^\&}\]

\[\dfrac{
    \rho,\mu,\chi,v \gives^e a \tto \mu_a,\nil,v_a
}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_ADDR}, \t{OP1}(\t{M\_DEREF}, a)) \tto \mu_a,\nil,v_a}\rule{Ptr}{^\&}\]

Dereferencing (added in \Cmp):
\[\dfrac{
    \rho,\mu,\chi,v \gives^e a\tto \mu_a,\nil,v_a \qquad v_a\in\dom\mu_a
}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_DEREF}, a) \tto \mu_a,\nil,\mu_a^{64}(v_a)}\rule{Ptr}{}\]

When the operand raises a non-\nil\ flag:
\[\dfrac{
    \rho,\mu,\chi,v \gives^e e\tto \mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
}{\rho,\mu,\chi,v \gives^e \t{OP1}(op, e) \tto \mu_e,\chi_e,v_e}\rule{Op1}{^\chi}\]

\subsection{Binary operators}
Multiplication (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_MUL}, e_1, e_2) \tto \mu_1,\nil,v_1\times v_2}\rule{Mul}{}\]

Addition (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_ADD}, e_1, e_2) \tto \mu_1,\nil,v_1 + v_2}\rule{Add}{}\]

Subtraction (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_SUB}, e_1, e_2) \tto \mu_1,\nil,v_1 - v_2}\rule{Sub}{}\]

Division and remainder (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \qquad v_2\ne 0\\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_DIV}, e_1, e_2) \tto \mu_1,\nil,v_1\div v_2}\rule{Div}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \qquad v_2\ne 0\\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_MOD}, e_1, e_2) \tto \mu_1,\nil,v_1\mod v_2}\rule{Mod}{}\]

Shifts (added in \Cmp):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_SHL}, e_1, e_2) \tto \mu_1,\nil,v_1\times 2^{v_2}}\rule{Shl}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_SHR}, e_1, e_2) \tto \mu_1,\nil,v_1\div 2^{v_2}} \rule{Shr}{}\]

Let \(\dec: \{ \bot, \top \}^{64} \to \ZZ_{64}\) the function
\[(b_0, \cdots, b_{63}) \mapsto \sum_{i=0}^{63} (1\t{ if } b_i\t{ else }0)\times 2^i\]
and \(\bin = \dec^{-1}\).

We can now define bitwise operators as follows (added in \Cmp).\\
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives^e e_1\tto \mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_AND}, e_1, e_2) \tto \mu_1,\nil,\dec(b_0^1 \wedge b_0^2,\cdots, b_{63}^1 \wedge b_{63}^2),\mu_1} \rule{And}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives^e e_1\tto \mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_OR}, e_1, e_2) \tto \mu_1,\nil,\dec(b_0^1 \vee b_0^2,\cdots, b_{63}^1 \vee b_{63}^2),\mu_1} \rule{Ior}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives^e e_1\tto \mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(\t{S\_XOR}, e_1, e_2) \tto \mu_1,\nil,\dec(b_0^1 \oplus b_0^2,\cdots, b_{63}^1 \oplus b_{63}^2),\mu_1} \rule{Xor}{}\]

When one of the operands raises a non-\nil\ flag:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\chi_1,v_1 \\
    \chi_1\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP2}(op, e_1, e_2) \tto \mu_1,\chi_1,v_1} \rule{Op2}{^\chi}\]

\subsection{Comparisons}
All are the same as in \Cmm.
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 = v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_EQ}, e_1, e_2) \tto \mu_1,\nil,1}\rule{Eq}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 < v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_LT}, e_1, e_2) \tto \mu_1,\nil,1}\rule{Lt}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 \leq v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_LE}, e_1, e_2) \tto \mu_1,\nil,1}\rule{Le}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 \ne v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_EQ}, e_1, e_2) \tto \mu_1,\nil,0}\rule{Eq}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 \not< v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_LT}, e_1, e_2) \tto \mu_1,\nil,0}\rule{Lt}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 \not\leq v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_LE}, e_1, e_2) \tto \mu_1,\nil,0}\rule{Le}{^\bot}\]

For optimisation purposes mostly, the comparison operators \(\t{C\_NE}\), \(\t{C\_GT}\), \(\t{C\_GE}\) may be introduced by the compiler (not by the parser, however).\\
They are defined as
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 = v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_NE}, e_1, e_2) \tto \mu_1,\nil,0}\rule{Ne}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 \leq v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_GT}, e_1, e_2) \tto \mu_1,\nil,0}\rule{Gt}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 < v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_GE}, e_1, e_2) \tto \mu_1,\nil,0}\rule{Ge}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 \ne v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_NE}, e_1, e_2) \tto \mu_1,\nil,1}\rule{Ne}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 \not\leq v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_GT}, e_1, e_2) \tto \mu_1,\nil,1}\rule{Gt}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\nil,v_1 \\
    \qquad v_1 \not< v_2
\end{array}}{\rho,\mu,\nil,v \gives^e \t{CMP}(\t{C\_GE}, e_1, e_2) \tto \mu_1,\nil,1}\rule{Ge}{^\top}\]

When one of the operands raises a non-\nil\ flag:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e_2\tto \mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1\tto \mu_1,\chi_1,v_1 \\
    \chi_1\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^e \t{CMP}(op, e_1, e_2) \tto \mu_1,\chi_1,v_1} \rule{Cmp}{^\chi}\]

\subsection{Assignments}

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives^e \t{OP1}(\t{M\_ADDR}, a) \tto \mu_a,\nil,v_a
\end{array}}{\rho,\mu,\chi,v \gives^e \t{SET}(a, e) \tto \mu_a^{64}[v_a\mapsto v_e],\nil,v_e}\rule{Ptr}{^\gets}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives^e \t{OP1}(\t{M\_ADDR}, a) \tto \mu_a,\chi_a,v_a \qquad \chi_a\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^e \t{SET}(a, e) \tto \mu_a,\chi_a,v_a}\rule{Ptr}{^{\gets\chi}}\]

\subsection{Increments}
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_ADDR}, a)\tto \mu_a,\nil,v_a \\
    k = \mu_a^{64}(v_a)
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_POST\_INC}, a) \tto \mu_a^{64}[v_a\mapsto k+1],\nil,k} \rule{Post}{^\uparrow}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_ADDR}, a)\tto \mu_a,\nil,v_a \\
    k = \mu_a^{64}(v_a)
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_POST\_DEC}, a) \tto \mu_a^{64}[v_a\mapsto k-1],\nil,k} \rule{Post}{^\downarrow}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_ADDR}, a)\tto \mu_a,\nil,v_a \\
    k = \mu_a^{64}(v_a)
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_PRE\_INC}, a) \tto \mu_a^{64}[v_a\mapsto k+1],\nil,k+1} \rule{Pre}{^\uparrow}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_ADDR}, a)\tto \mu_a,\nil,v_a \\
    k = \mu_a^{64}(v_a)
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OP1}(\t{M\_PRE\_DEC}, a) \tto \mu_a^{64}[v_a\mapsto k-1],\nil,k-1} \rule{Pre}{^\downarrow}\]


\subsection{Extended assignments}
Let \(op\in \t{bin\_op}\setminus \{ \t{S\_INDEX} \}\).

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives^e \t{OP1}(\t{M\_ADDR}, a) \tto \mu_a,\chi_a,v_a \\
    v_a\in\dom\mu_a \qquad \mu_a^{64}(v_a) = u \\
    \rho,\mu_a,\chi_a,v_a \gives^e \t{OP2}(op, \t{CST}\ v_a, \t{CST}\ v_e) \tto \mu',\nil,w
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OPSET}(op, a, e) \tto \mu'[v_a\mapsto w],\nil,w} \rule{Opset}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e\tto \mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives^e \t{OP1}(\t{M\_ADDR}, a) \tto \mu_a,\chi_a,v_a \\
    \chi_a\ne\nil \\
\end{array}}{\rho,\mu,\chi,v \gives^e \t{OPSET}(op, a, e) \tto \mu_a,\chi_a,v_a} \rule{Opset}{^\chi}\]

\subsection{Ternary operator}
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e\tto \mu_e,\nil,v_e \qquad v_e = 0\\
    \rho,\mu_e,\nil,v_e \gives^e e_\bot \tto \mu_\bot,\chi_\bot,v_\bot
\end{array}}{\rho,\mu,\chi,v \gives^e \t{EIF}(e, e_\top, e_\bot) \tto \mu_\bot,\chi_\bot,v_\bot}\rule{Tern}{^\bot}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e\tto \mu_e,\nil,v_e \qquad v_e \ne 0\\
    \rho,\mu_e,\nil,v_e \gives^e e_\top \tto \mu_\top,\chi_\top,v_\top \\
\end{array}}{\rho,\mu,\chi,v \gives^e \t{EIF}(e, e_\top, e_\bot) \tto \mu_\top,\chi_\top,v_\top}\rule{Tern}{^\top}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e\tto \mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^e \t{EIF}(e, e_\top, e_\bot) \tto \mu_e,\chi_e,v_e}\rule{Tern}{^\chi}\]


\subsection{Sequence}
\[\dfrac{\begin{array}{c}
    \rho,\mu_0,\chi_0,v_0 \gives^e e_1 \tto \mu_1,\chi_1,v_1 \\
    \cdots \\
    \rho,\mu_{n-1},\chi_{n-1},v_{n-1} \gives^e e_n \tto \mu_n,\chi_n,v_n \\
\end{array}}{\rho,\mu_0,\chi_0,v_0 \gives^e \t{ESEQ}\ [e_1;\cdots;e_n] \tto \mu_n,\chi_n,v_n} \rule{Seq}{^n}\]

\subsection{Function call}
Works for both a toplevel function and a function pointer:
\[\dfrac{\begin{array}{c}
    \rho,\mu_{n+1},\chi_{n+1},v_{n+1} \gives^e e_n \tto \mu_n,\chi_n,v_n \\
    \cdots \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1 \tto \mu_1,\nil,v_1 \\
    f\in\dom\fun \\
    \rho_g,\mu_1,\nil,0 \gives^e \fun(f)(v_1, \cdots, v_n) \tto \rho_f,\mu_f,\chi_f,v_f
\end{array}}{\rho,\mu_n,\chi_n,v_n \gives^e \t{CALL}(f, [e_1; \cdots; e_n]) \tto \mu_f,\chi_f,v_f} \rule{Call}{^n}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu_{n+1},\chi_{n+1},v_{n+1} \gives^e e_n \tto \mu_n,\chi_n,v_n \\
    \cdots \\
    \rho,\mu_2,\chi_2,v_2 \gives^e e_1 \tto \mu_1,\chi_1,v_1 \\
    \chi_1\ne\nil \\
\end{array}}{\rho,\mu_{n+1},\chi_{n+1},v_{n+1} \gives^e \t{CALL}(f, [e_1; \cdots; e_n]) \tto \mu_1,\chi_1,v_1} \rule{Call}{^\chi}\]


\section{Code}
\subsection{Expressions}
An expression as statement is simply executed. If a non-\nil\ flag is raised, it will be skipped anyway.\\
\[\dfrac{
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e
}{\rho,\mu,\chi,v \gives^c \t{CEXPR}\ e \tto \rho,\mu_e,\chi_e,v_e}\rule{Expr}{}\]

\subsection{Conditional branching}
If only \nil\ is raised after the evaluation of the condition, one of the two branches is executed.
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e \qquad v_e = 0 \\
    \rho,\mu_e,\nil,v_e \gives^c c_\bot \tto \rho_\bot,\mu_\bot,\chi_\bot,v_\bot \\
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu_\bot,\chi_\bot,v_\bot} \rule{If}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e \qquad v_e \ne 0 \\
    \rho,\mu_e,\nil,v_e \gives^c c_\top \tto \rho_\top,\mu_\top,\chi_\top,v_\top \\
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu_\top,\chi_\top,v_\top} \rule{If}{^\top}\]
Note that the branch is allowed to modify the memory and raise flags, but not change the environment: \(\rho\) is preserved.\\

For all other flags, neither of the branches is executed.
\[\dfrac{\begin{array}{c}
\rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e \qquad \chi_e\ne\nil \\
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu_e,\chi_e,v_e} \rule{If}{^\chi}\]

\subsection{Blocks}
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^c c \tto \rho',\mu',\chi',v' \\
    \rho',\mu',\chi',v' \gives^c \t{CBLOCK}\ S \tto \rho'',\mu'',\chi'',v''
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CBLOCK}(c :: S) \tto \rho,\mu'',\chi'',v''} \rule{Block}{^1}\]
\[\dfrac{}{\rho,\mu,\chi,v \gives^c \t{CBLOCK}\ [] \tto \rho,\mu,\chi,v} \rule{Block}{^0}\]
Again for blocks, the memory may be changed and flags may be raised, but the environment is preserved.\\

\subsection{Loops}

A loop with a false condition stops:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e \qquad v_e = 0 \\
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu',\nil,v} \rule{While}{^{\bot,\t{true}}}\]

Except in the case of a \t{do-while}:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^c c \tto \rho_c,\mu_c,\chi_c,v_c \\
    \rho,\mu_c,\chi_c,v_c \gives^e f \tto \mu_f,\nil,v_f \\
    \rho,\mu_f,\nil,v_f \gives^c \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e, c, f, \t{false}) \tto \rho,\mu_w,\chi_w,v_w} \rule{While}{^{\t{false}}}\]

A loop continues normally if its condition is nonzero:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e \qquad v_e \ne 0 \\
    \rho,\mu_e,\nil,v_e \gives^c c \tto \rho_c,\mu_c,\chi_c,v_c \qquad \chi_c\not\in\{ \brk, \cnt \} \\
    \rho,\mu_c,\chi_c,v_c \gives^e f \tto \mu_f,\chi_f,v_f \\
    \rho,\mu_f,\chi_f,v_f \gives^c \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w} \rule{While}{^{\top,\t{true}}}\]

A flag skips the loop:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e \qquad \chi_e\ne\nil \\
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e,c,f,\t{true}) \tto \rho,\mu_e,\chi_e,v_e} \rule{While}{^{\chi,\t{true}}}\]
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e,c,f,\t{false}) \tto \rho,\mu,\chi,v} \rule{While}{^{\chi,\t{false}}}\]

\cnt\ executes the finally clause before continuing as normal:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e \qquad v_e \ne 0 \\
    \rho,\mu_e,\nil,v_e \gives^c c \tto \rho_c,\mu_c,\cnt,v_c \\
    \rho,\mu_c,\nil,v_c \gives^e f \tto \mu_f,\chi_f,v_f \\
    \rho,\mu_f,\chi_f,v_f \gives^c \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w} \rule{While}{^{\cnt,\t{true}}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^c c \tto \rho_c,\mu_c,\cnt,v_c \\
    \rho,\mu_c,\nil,v_c \gives^e f \tto \mu_f,\chi_f,v_f \\
    \rho,\mu_f,\chi_f,v_f \gives^c \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e, c, f, \t{false}) \tto \rho,\mu_w,\chi_w,v_w} \rule{While}{^{\cnt,\t{false}}}\]

\brk\ interrupts the loop but is not retransmitted:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e \qquad v_e \ne 0 \\
    \rho,\mu_e,\nil,v_e \gives^c c \tto \rho_c,\mu_c,\brk,v_c \\
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_c,\nil,v_c} \rule{While}{^{\brk,\t{true}}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^c c \tto \rho_c,\mu_c,\brk,v_c \\
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CWHILE}(e, c, f, \t{false}) \tto \rho,\mu_c,\nil,v_c} \rule{While}{^{\brk,\t{false}}}\]

\subsection{Control flow}
\[\dfrac{
}{\rho,\mu,\nil,v \gives^c \t{CBREAK} \tto \rho,\mu,\brk,0} \rule{Break}{}\]
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CBREAK} \tto \rho,\mu,\chi,v} \rule{Break}{^\chi}\]

\[\dfrac{
}{\rho,\mu,\nil,v \gives^c \t{CCONTINUE} \tto \rho,\mu,\cnt,0} \rule{Continue}{}\]
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CCONTINUE} \tto \rho,\mu,\chi,v} \rule{Continue}{^\chi}\]

\[\dfrac{
}{\rho,\mu,\nil,v \gives^c \t{CRETURN}\ \t{None} \tto \rho,\mu,\ret,0} \rule{Return}{^\t{None}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e
\end{array}}{\rho,\mu,\nil,v \gives^c \t{CRETURN}(\t{Some}\ e) \tto \rho,\mu_e,\ret,v_e} \rule{Return}{^\t{Some}}\]

\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CRETURN}\ \t{None} \tto \rho,\mu,\chi,v} \rule{Return}{^{\t{None}\chi}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
\end{array}}{\rho,\mu,\nil,v \gives^c \t{CRETURN}(\t{Some}\ e) \tto \rho,\mu_e,\chi_e,v_e} \rule{Return}{^{\t{Some}\chi}}\]

\subsection{Local variable declarations}

First, the obvious:
\[\dfrac{\begin{array}{c}
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CLOCAL}\ [] \tto \rho,\mu,\chi,v} \rule{Local}{^0}\]
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CLOCAL}\ d \tto \rho,\mu,\chi,v} \rule{Local}{^\chi}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e \\
    k \in alloc^8(\mu_e) \qquad \rho' = \rho[w \mapsto k] \qquad \mu' = \mu_e[k \mapsto v_e] \\
    \rho',\mu',\nil,v_e \gives^c \t{CLOCAL}\ S \tto \rho_s,\mu_s,\chi_s,v_s
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CLOCAL}((w,e)::S) \tto \rho_s,\mu_s,\chi_s,v_s} \rule{Local}{^1}\]

\subsection{Throw}
If a flag is already raised, skip the \t{CTHROW}:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CTHROW}(s,e) \tto \rho,\mu_e,\chi_e,v_e} \rule{Throw}{^\chi}\]

Otherwise raise the new exception \(s\in S\):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\nil,v_e
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CTHROW}(s,e) \tto \rho,\mu_e,s,v_e} \rule{Throw}{}\]

\subsection{Switch}

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives^e e \tto \mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives^c \t{CBLOCK}(L(v_e)) \tto \rho,\mu_l,\chi_l,v_l
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CSWITCH}(e, L, c) \tto \rho,\mu_l,\chi_l,v_l} \rule{Switch}{}\]

Where for \(L = [(j_1, l_1); \cdots; (j_n,l_n)]\), \(L(v_e)\) is defined as follows : \\
Let \(I_i =  \{ j_1, \cdots, j_i \}\) for \(1 \leq i \leq n\), \(I_{n+1} = \ZZ_{64}\). \\
\(\tilde{j} \triangleq \min_{1\leq i \leq n+1} \{ i\ |\ v_e\in I_i \}\), finally \(L(v_e) \triangleq [l_{\tilde{j}}; \cdots; l_n; c]\).

\subsection{Try}

Skip the block when a flag is already raised:
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives^c \t{CTRY}(c, L, f) \tto \rho,\mu,\chi,v} \rule{Try}{^\chi}\]

For \(L = [(e_1, x_1, c_1); \cdots; (e_n, x_n, c_n)]\), let \(E = \{ e_i | 1 \leq i \leq n \} \subset S\).

When no exception is raised:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\nil,v \gives^c c \tto \rho_c,\mu_c,\nil,v_c \\
    \rho,\mu_c,\nil,v_c \gives^c f \tto \rho_f,\mu_f,\chi_f,v_f
\end{array}}{\rho,\mu,\nil,v \gives^c \t{CTRY}(c, L, f) \tto \rho,\mu_f,\chi_f,v_f} \rule{Try}{^\nil}\]

When an exception is raised that is not caught by the current handler:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\nil,v \gives^c c \tto \rho_c,\mu_c,s_c,v_c \\
    s_c \not\in E \qquad \t{\_}\not\in E \\
    \rho,\mu,\nil,v_c \gives^c f \tto \rho_f,\mu_f,\nil,v_f
\end{array}}{\rho,\mu,\nil,v \gives^c \tto \t{CTRY}(c, L, f) \tto \rho,\mu_f,s_c,v_c} \rule{Try}{^{\nil'}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\nil,v \gives^c c \tto \rho_c,\mu_c,s_c,v_c \\
    s_c \not\in E \qquad \t{\_}\not\in E \\
    \rho,\mu,\nil,v_c \gives^c f \tto \rho_f,\mu_f,\chi_f,v_f \qquad \chi_f\ne\nil
\end{array}}{\rho,\mu,\nil,v \gives^c \tto \t{CTRY}(c, L, f) \tto \rho,\mu_f,\chi_f,v_f} \rule{Try}{^{\chi'}}\]

When the handler is able to catch the exception:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\nil,v \gives^c c \tto \rho_c,\mu_c,s_c,v_c \\
    s_c = e_{i_0} \qquad x_{i_0} \ne \t{\_} \\
    k\in alloc^8(\mu) \qquad \rho[x_{i_0}\mapsto k],\mu_c[k\mapsto v_c],\nil,v_c \gives^c c_{i_0} \tto \rho_0,\mu_0,\chi_0,v_0 \\
    \rho,\mu_0,\chi_0,v_0 \gives^c f \tto \rho_f,\mu_f,\chi_f,v_f
\end{array}}{\rho,\mu,\nil,v \gives^c \t{CTRY}(c, L, f) \tto \rho,\mu_f,\chi_f,v_f} \rule{Try}{^s}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\nil,v \gives^c c \tto \rho_c,\mu_c,s_c,v_c \\
    s_c = e_{i_0} \qquad x_{i_0} = \t{\_} \\
    \rho,\mu_c,\nil,v_c \gives^c c_{i_0} \tto \rho_0,\mu_0,\chi_0,v_0 \\
    \rho,\mu_0,\chi_0,v_0 \gives^c f \tto \rho_f,\mu_f,\chi_f,v_f
\end{array}}{\rho,\mu,\nil,v \gives^c \t{CTRY}(c, L, f) \tto \rho,\mu_f,\chi_f,v_f} \rule{Try}{^s}\]
\end{document}
