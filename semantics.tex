\input{header.tex}

\newcommand{\Cmp}{\(\pm\)C}
\newcommand{\Cmm}{C\textminus\textminus}
\newcommand{\fun}{\text{fun}_\pi^n}
\newcommand{\fnptr}{\text{fun}_\mu^n}
\newcommand{\gives}{\vdash_\pi}
\newcommand{\brk}{\t{brk}}
\newcommand{\ret}{\t{ret}}
\newcommand{\cnt}{\t{cnt}}
\newcommand{\nil}{\t{nil}}

\title{Semantics of \Cmp (i.e. extended \Cmm)}
\author{\textsc{Villani} Neven, ENS Paris-Saclay\\\textsc{Programmation 1 -- Compilateur COCass}}

\begin{document}
\maketitle

Retranscribed and extended from \url{http://www.lsv.fr/~goubault/CoursProgrammation/minic.html}\\
and \url{http://www.lsv.fr/~goubault/CoursProgrammation/prog1_sem1.pdf}.\\


\section*{Notation}

\(\ZZ_{64}\) is the set of 64-bit signed integers, in which all calculations are done when not specified otherwise.\\

We write \((\rho: \mathcal{S}\to\ZZ_{64})\in \mathcal{P}\) the environment, where \(\mathcal{S}\) is the set of names of variables and functions, \((\mu: \ZZ_{64}\to\ZZ_{8})\in \mathcal{M}\) the memory.\\
\(\mu\) is read by blocks of 8 bytes : \(\mu^{64}(i) \triangleq \sum_{k=0}^7 2^{8k}\mu(i+k)\).\\
\(\rho_g\in\mathcal{P}\) is the global environment.\\

A flag is defined as an element of \(\mathcal{E} \triangleq S \sqcup \{ \brk, \ret, \cnt, \nil \}\): either an exception string or a special control flow keyword.\\
Intuitively, \(\rho,\mu,\chi,v \gives c \tto \rho',\mu',\chi',v'\) means that when \(c\) is executed under the environment \(\rho\) with the memory \(\mu\), the flag \(\chi\), and the previous value \(v\), it updates it to the new environment and memory \(\rho'\) and \(\mu'\), raises \(\chi'\), and changes the value to \(v'\).\\

In addition, we write \(\fun: \ZZ_{64}\to \t{code}\), a wrapper around \Cmp\ functions: \(\fun(a)(p_1, \cdots, p_n) = c\) updates the environment with \(p_1, \cdots, p_n\) and executes the body of the function whose definition was given by the code \(c\) and stored at \(a\). This way of considering functions allows in particular for function pointers.\\

For \(\mu\in\mathcal{M}, v\in\ZZ_{8}, x\in\ZZ_{64}\) we write \(\mu[x\mapsto v]: \left\{\begin{array}{ll}x\mapsto v & \\ y\mapsto \mu(y) & y\in \dom\mu\setminus\{x\}\end{array}\right.\)\\
However we will usually use \(\mu^{64}[x\mapsto v] \triangleq\mu[x+k\mapsto v_k\ |\  0\leq k<8,\ v = \sum_{k=0}^8 2^{8k}v_k]\), i.e. the memory is written 8 bytes at a time.\\

A similar notation is used for \(\rho\), \(\rho_g\) and \(\fun\).

\section{Expressions}
\subsection{Reading values}
For local and global variables:
\[\dfrac{x\in\dom\rho \qquad \rho(x)\in\dom\mu}{\rho,\mu,\nil,v \gives \t{VAR}\ x\tto \rho,\mu,\nil,\mu^{64}(\rho(x))}\rule{Var}{}\]
i.e. reading a variable returns its contents and changes nothing to the memory.\\
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives \t{VAR}\ x\tto \rho,\mu,\chi,v} \rule{Var}{^\chi}\]

For constant integers:
\[\dfrac{}{\rho,\mu,\nil,v \gives \t{CST}\ n\tto \rho,\mu,\nil,n}\rule{Cst}{}\]
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives \t{CST}\ n\tto \rho,\mu,\chi,v} \rule{Cst}{^\chi}\]

For strings:
\[\dfrac{s\text{ stored at }a\in Addr}{\rho,\mu,\nil,v \gives \t{STRING}\ s\tto \rho,\mu,\nil,a}\rule{Str}{}\]
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives \t{STRING}\ s\tto \rho,\mu,\chi,v} \rule{Cst}{^\chi}\]

For arrays:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,i \gives a\tto \rho,\mu_a,\nil,v_a \\
    v_a+v_i\times 8\in\dom\mu_a
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_INDEX}, a, i) \tto \rho,\mu_a,\nil,\mu_a^{64}(v_a+v_i\times 8)}\rule{Idx}{}\]

None of these are different from the original \Cmm\ semantics.

\subsection{Unary operators without side-effects}
Unary minus (same as \Cmm):
\[\dfrac{
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_MINUS}, e) \tto \rho,\mu_e,\nil,-v_e}\rule{Neg}{}\]

Unary bitwise negation (same as \Cmm):
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_NOT}, e) \tto \rho,\mu_e,\nil,-v_e-1}\rule{Not}{}\]


Indirection (added in \Cmp):
\[\dfrac{
    x\in\dom\rho
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_ADDR}, \t{VAR}\ x)\tto \rho,\mu,\nil,\rho(x)}\rule{Var}{^\&}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu_a,\nil,v_a \\
\end{array}}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_ADDR}, \t{OP2}(\t{S\_INDEX}, a, i)) \tto \rho,\mu_a,\nil,v_a+v_i\times 8}\rule{Idx}{^\&}\]

\[\dfrac{
    \rho,\mu,\chi,v \gives a \tto \rho,\mu_a,\nil,v_a
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_ADDR}, \t{OP1}(\t{M\_DEREF}, a)) \tto \rho,\mu_a,\nil,v_a}\rule{Ptr}{^\&}\]

Dereferencing (added in \Cmp):
\[\dfrac{
    \rho,\mu,\chi,v \gives a\tto \rho,\mu_a,\nil,v_a \qquad v_a\in\dom\mu_a
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_DEREF}, a) \tto \rho,\mu_a,\nil,\mu_a^{64}(v_a)}\rule{Ptr}{}\]

When the operand raises a non-\nil\ flag:
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
}{\rho,\mu,\chi,v \gives \t{OP1}(op, e) \tto \rho,\mu_e,\chi_e,v_e}\rule{Op1}{^\chi}\]

\subsection{Binary operators}
Multiplication (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_MUL}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\times v_2}\rule{Mul}{}\]

Addition (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_ADD}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1 + v_2}\rule{Add}{}\]

Subtraction (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_SUB}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1 - v_2}\rule{Sub}{}\]

Division and remainder (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad v_2\ne 0\\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_DIV}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\div v_2}\rule{Div}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad v_2\ne 0\\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_MOD}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\mod v_2}\rule{Mod}{}\]

Shifts (added in \Cmp):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_SHL}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\times 2^{v_2}}\rule{Shl}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_SHR}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\div 2^{v_2}} \rule{Shr}{}\]

Let \(\dec: \{ \bot, \top \}^{64} \to \ZZ_{64}\) the function
\[(b_0, \cdots, b_{63}) \mapsto \sum_{i=0}^{63} (1\t{ if } b_i\t{ else }0)\times 2^i\]
and \(\bin = \dec^{-1}\).

We can now define bitwise operators as follows (added in \Cmp).\\
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_AND}, e_1, e_2) \tto \rho,\mu_1,\nil,\dec(b_0^1 \wedge b_0^2,\cdots, b_{63}^1 \wedge b_{63}^2),\mu_1} \rule{And}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_OR}, e_1, e_2) \tto \rho,\mu_1,\nil,\dec(b_0^1 \vee b_0^2,\cdots, b_{63}^1 \vee b_{63}^2),\mu_1} \rule{Ior}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_XOR}, e_1, e_2) \tto \rho,\mu_1,\nil,\dec(b_0^1 \oplus b_0^2,\cdots, b_{63}^1 \oplus b_{63}^2),\mu_1} \rule{Xor}{}\]

When one of the operands raises a non-\nil\ flag:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\chi_1,v_1 \\
    \chi_1\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(op, e_1, e_2) \tto \rho,\mu_1,\chi_1,v_1} \rule{Op2}{^\chi}\]

\subsection{Comparisons}
All are the same as in \Cmm.
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 = v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_EQ}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Eq}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 < v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_LT}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Lt}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \leq v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_LE}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Le}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \ne v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_EQ}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Eq}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \not< v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_LT}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Lt}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \not\leq v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_LE}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Le}{^\bot}\]

For optimisation purposes mostly, the comparison operators \(\t{C\_NE}\), \(\t{C\_GT}\), \(\t{C\_GE}\) may be introduced by the compiler (not by the parser, however).\\
They are defined as
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 = v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_NE}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Ne}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \leq v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_GT}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Gt}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 < v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_GE}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Ge}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \ne v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_NE}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Ne}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \not\leq v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_GT}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Gt}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \not< v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_GE}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Ge}{^\top}\]

When one of the operands raises a non-\nil\ flag:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\chi_1,v_1 \\
    \chi_1\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{CMP}(op, e_1, e_2) \tto \rho,\mu_1,\chi_1,v_1} \rule{Cmp}{^\chi}\]

\subsection{Assignments}

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e \\
    x\in\dom\rho \qquad \rho(x)\in\dom\mu_e
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_VAR}(x, e) \tto \rho,\mu_e^{64}[\rho(x)\mapsto v_e],\nil,v_e}\rule{Var}{^\gets}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_VAR}(x, e) \tto \rho,\mu_e,\chi_e,v_e}\rule{Var}{^{\gets\chi}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives i\tto \rho,\mu_i,\nil,v_i \\
    \rho(x)\in\dom\mu_i
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_ARRAY}(x, i, e) \tto \rho,\mu_i^{64}[\rho(x)+v_i\times 8 \mapsto v_e],\nil,v_e}\rule{Idx}{^\gets}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives i\tto \rho,\mu_i,\chi_i,v_i \qquad \chi_i\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_ARRAY}(x, i, e) \tto \rho,\mu_i,\chi_i,v_i}\rule{Idx}{^{\gets\chi}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives a \tto \rho,\mu_a,\nil,v_a
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_DEREF}(a, e) \tto \rho,\mu_a^{64}[v_a\mapsto v_e],\nil,v_e}\rule{Ptr}{^\gets}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives a \tto \rho,\mu_a,\chi_a,v_a \qquad \chi_a\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_DEREF}(a, e) \tto \rho,\mu_a,\chi_a,v_a}\rule{Ptr}{^{\gets\chi}}\]

\subsection{Increments}
On variables:
\[\dfrac{
    x\in\dom\rho \qquad \rho(x) = k \in\dom\mu \qquad \mu^{64}(k) = v_k
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_POST\_INC}, \t{VAR}\ x) \tto \rho,\mu^{64}[k\mapsto v_k+1],\nil,v_k} \rule{Var}{^{\bullet\uparrow}}\]
\[\dfrac{
    x\in\dom\rho \qquad \rho(x) = k \in\dom\mu \qquad \mu^{64}(k) = v_k
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_POST\_DEC}, \t{VAR}\ x) \tto \rho,\mu^{64}[k\mapsto v_k-1],\nil,v_k} \rule{Var}{^{\bullet\downarrow}}\]
\[\dfrac{
    x\in\dom\rho \qquad \rho(x) = k \in\dom\mu \qquad \mu^{64}(k)+1 = v_k
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_PRE\_INC}, \t{VAR}\ x) \tto \rho,\mu^{64}[k\mapsto v_k],\nil,v_k} \rule{Var}{^{\uparrow \bullet}}\]
\[\dfrac{
    x\in\dom\rho \qquad \rho(x) = k \in\dom\mu \qquad \mu^{64}(k)-1 = v_k
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_PRE\_DEC}, \t{VAR}\ x) \tto \rho,\mu^{64}[k\mapsto v_k],\nil,v_k} \rule{Var}{^{\downarrow \bullet}}\]

On arrays:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu_a,\nil,v_a \\
    v_a+v_i\times8 = k \qquad k\in\dom\mu_a
\end{array}}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_POST\_INC}, \t{OP2}(\t{S\_INDEX}, a, e)) \tto \rho,\mu_a^{64}[k \mapsto \mu_a(k)+1],\nil,\mu_a^{64}(k)}\rule{Idx}{^{\bullet\uparrow}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu_a,\nil,v_a \\
    v_a+v_i\times8 = k \qquad k\in\dom\mu_a
\end{array}}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_POST\_DEC}, \t{OP2}(\t{S\_INDEX}, a, e)) \tto \rho,\mu_a^{64}[k \mapsto \mu_a(k)-1],\nil,\mu_a^{64}(k)}\rule{Idx}{^{\bullet\downarrow}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu_a,\nil,v_a \\
    v_a+v_i\times8 = k \qquad k\in\dom\mu_a \qquad \mu_a^{64}(k)+1 = v_k
\end{array}}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_PRE\_INC}, \t{OP2}(\t{S\_INDEX}, a, e)) \tto \rho,\mu_a[k \mapsto v_k],\nil,v_k}\rule{Idx}{^{\uparrow \bullet}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu_a,\nil,v_a \\
    v_a+v_i\times8 = k \qquad k\in\dom\mu_a \qquad \mu_a^{64}(k)-1 = v_k
\end{array}}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_PRE\_DEC}, \t{OP2}(\t{S\_INDEX}, a, e)) \tto \rho,\mu_a[k \mapsto v_k],\nil,v_k}\rule{Idx}{^{\downarrow \bullet}}\]

On dereferences:
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_POST\_INC}, \t{OP1}(\t{M\_DEREF}, e)) \tto \rho,\mu_e^{64}[v_e\mapsto \mu_e(v_e)+1],\nil,\mu_e(v_e)} \rule{Ptr}{^{\bullet\uparrow}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_POST\_DEC}, \t{OP1}(\t{M\_DEREF}, e)) \tto \rho,\mu_e^{64}[v_e\mapsto \mu_e(v_e)-1],\nil,\mu_e^{64}(v_e)} \rule{Ptr}{^{\bullet\downarrow}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e \qquad \mu_e^{64}(v_e)+1 = k
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_PRE\_INC}, \t{OP1}(\t{M\_DEREF}, e)) \tto \rho,\mu_e[v_e\mapsto k],\nil,k} \rule{Ptr}{^{\uparrow \bullet}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e \qquad \mu_e^{64}(v_e)-1 = k
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_PRE\_DEC}, \t{OP1}(\t{M\_DEREF}, e)) \tto \rho,\mu_e[v_e\mapsto k],\nil,k} \rule{Ptr}{^{\downarrow \bullet}}\]

\subsection{Extended assignments}
Let \(op\in \t{bin\_op}\setminus \{ \t{S\_INDEX} \}\).

On variables:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \\
    x\in\dom\rho \qquad \rho(x)\in\dom(\mu_e) \qquad \rho(x) = k \qquad \mu_e^{64}(k) = u \\
    \rho,\mu_e,\chi_e,v_e \gives \t{OP2}(op, \t{CST}\ v, \t{CST}\ u) \tto \rho,\mu',\nil,w
\end{array}}{\rho,\mu,\chi,v \gives \t{OPSET\_VAR}(op, x, e) \tto \rho,\mu'[k\mapsto w],\nil,w} \rule{Var}{^{\gets op}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil\\
\end{array}}{\rho,\mu,\chi,v \gives \t{OPSET\_VAR}(op, x, e) \tto \rho,\mu_e,\chi_e,v_e} \rule{Var}{^{\gets op\chi}}\]

On arrays:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    t\in\dom\rho \qquad \rho(t)+v_i\times8 = k \qquad k\in\dom\mu_i\\
    \mu_i^{64}(k) = u \qquad \rho,\mu_i,\chi_i,v_i \gives \t{OP2}(op, \t{CST}\ v, \t{CST}\ u) \tto \rho,\mu',\t,\nil,w
\end{array}}{\rho,\mu,\chi,v \gives \t{OPSET\_ARRAY}(op, t, e_1, e_2) \tto \rho,\mu'[k\mapsto w],\nil,w} \rule{Idx}{^{\gets op}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives i\tto \rho,\mu_i,\chi_i,v_i \qquad \chi_i\ne\nil\\
\end{array}}{\rho,\mu,\chi,v \gives \t{OPSET\_ARRAY}(op, t, e_1, e_2) \tto \rho,\mu_i,\chi_i,v_i} \rule{Idx}{^{\gets op\chi}}\]

On dereferences:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives a\tto \rho,\mu_a,\chi_a,v_a \\
    \rho,\mu_a,\chi_a,v_a \gives e\tto \rho,\mu_e,\chi_e,v_e \\
    v_e\in\dom\mu_e \qquad \mu_e^{64}(v_e) = u \\
    \rho,\mu_e,\chi_e,v_e \gives \t{OP2}(op, \t{CST}\ v, \t{CST}\ u) \tto \rho,\mu',\nil,w
\end{array}}{\rho,\mu,\chi,v \gives \t{OPSET\_DEREF}(op, e_1, e_2) \tto \rho,\mu'[k\mapsto w],\nil,w} \rule{Ptr}{^{\gets op}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives a\tto \rho,\mu_a,\chi_a,v_a \\
    \rho,\mu_a,\chi_a,v_a \gives e\tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil \\
\end{array}}{\rho,\mu,\chi,v \gives \t{OPSET\_DEREF}(op, e_1, e_2) \tto \rho,\mu_e,\chi_e,v_e} \rule{Ptr}{^{\gets op\chi}}\]

\subsection{Ternary operator}
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e \qquad v_e = 0\\
    \rho,\mu_e,\nil,v_e \gives e_\bot \tto \rho,\mu_\bot,\chi_\bot,v_\bot
\end{array}}{\rho,\mu,\chi,v \gives \t{EIF}(e, e_\top, e_\bot) \tto \rho,\mu_\bot,\chi_\bot,v_\bot}\rule{Tern}{^\bot}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e \qquad v_e \ne 0\\
    \rho,\mu_e,\nil,v_e \gives e_\top \tto \rho,\mu_\top,\chi_\top,v_\top \\
\end{array}}{\rho,\mu,\chi,v \gives \t{EIF}(e, e_\top, e_\bot) \tto \rho,\mu_\top,\chi_\top,v_\top}\rule{Tern}{^\top}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{EIF}(e, e_\top, e_\bot) \tto \rho,\mu_e,\chi_e,v_e}\rule{Tern}{^\chi}\]


\subsection{Sequence}
\[\dfrac{\begin{array}{c}
    \rho,\mu_0,\chi_0,v_0 \gives e_1 \tto \rho,\mu_1,\chi_1,v_1 \\
    \cdots \\
    \rho,\mu_{n-1},\chi_{n-1},v_{n-1} \gives e_n \tto \rho,\mu_n,\chi_n,v_n \\
\end{array}}{\rho,\mu_0,\chi_0,v_0 \gives \t{ESEQ}\ [e_1;\cdots;e_n] \tto \rho,\mu_n,\chi_n,v_n} \rule{Seq}{^n}\]

\subsection{Function call}
Works for both a toplevel function and a function pointer:
\[\dfrac{\begin{array}{c}
    \rho,\mu_{n+1},\chi_{n+1},v_{n+1} \gives e_n \tto \rho,\mu_n,\chi_n,v_n \\
    \cdots \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1 \tto \rho,\mu_1,\nil,v_1 \\
    f\in\dom\fun \\
    \rho_g,\mu_1,\nil,0 \gives \fun(f)(v_1, \cdots, v_n) \tto \rho_f,\mu_f,\chi_f,v_f
\end{array}}{\rho,\mu_n,\chi_n,v_n \gives \t{CALL}(f, [e_1; \cdots; e_n]) \tto \rho,\mu_f,\chi_f,v_f} \rule{Call}{^n}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu_{n+1},\chi_{n+1},v_{n+1} \gives e_n \tto \rho,\mu_n,\chi_n,v_n \\
    \cdots \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1 \tto \rho,\mu_1,\chi_1,v_1 \\
    \chi_1\ne\nil \\
\end{array}}{\rho,\mu_{n+1},\chi_{n+1},v_{n+1} \gives \t{CALL}(f, [e_1; \cdots; e_n]) \tto \rho,\mu_1,\chi_1,v_1} \rule{Call}{^\chi}\]


\section{Code}
\subsection{Expressions}
An expression as statement is simply executed. If a non-\nil\ flag is raised, it will be skipped anyway.\\
\[\dfrac{
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e
}{\rho,\mu,\chi,v \Vdash_\pi \t{CEXPR}\ e \tto \rho,\mu_e,\chi_e,v_e}\rule{Expr}{}\]

\subsection{Conditional branching}
If only \nil\ is raised after the evaluation of the condition, one of the two branches is executed.
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e \qquad v_e = 0 \\
    \rho,\mu_e,\nil,v_e \gives c_\bot \tto \rho_\bot,\mu_\bot,\chi_\bot,v_\bot \\
\end{array}}{\rho,\mu,\chi,v \gives \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu_\bot,\chi_\bot,v_\bot} \rule{If}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e \qquad v_e \ne 0 \\
    \rho,\mu_e,\nil,v_e \gives c_\top \tto \rho_\top,\mu_\top,\chi_\top,v_\top \\
\end{array}}{\rho,\mu,\chi,v \gives \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu_\top,\chi_\top,v_\top} \rule{If}{^\top}\]
Note that the branch is allowed to modify the memory and raise flags, but not change the environment: \(\rho\) is preserved.\\

For all other flags, neither of the branches is executed.
\[\dfrac{\begin{array}{c}
\rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil \\
\end{array}}{\rho,\mu,\chi,v \gives \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu_e,\chi_e,v_e} \rule{If}{^\chi}\]

\subsection{Blocks}
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives c \tto \rho',\mu',\chi',v' \\
    \rho',\mu',\chi',v' \gives \t{CBLOCK}\ S \tto \rho'',\mu'',\chi'',v''
\end{array}}{\rho,\mu,\chi,v \gives \t{CBLOCK}(c :: S) \tto \rho,\mu'',\chi'',v''} \rule{Block}{^1}\]
\[\dfrac{}{\rho,\mu,\chi,v \gives \t{CBLOCK}\ [] \tto \rho,\mu,\chi,v} \rule{Block}{^0}\]
Again for blocks, the memory may be changed and flags may be raised, but the environment is preserved.\\

\subsection{Loops}

\[\dfrac{
}{\rho,\mu,\chi,v \gives \t{None} \tto \rho,\mu,\chi,v} \rule{None}{}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives f \tto \rho_f,\mu_f,\chi_f,v_f
}{\rho,\mu,\chi,v \gives \t{Some}\ f \tto \rho_f,\mu_f,\chi_f,v_f} \rule{Some}{}\]

A loop with a false condition stops:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e \qquad v_e = 0 \\
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu',\nil,v} \rule{While}{^{\bot,\t{true}}}\]

Except in the case of a \t{do-while}:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives c \tto \rho_c,\mu_c,\chi_c,v_c \\
    \rho,\mu_c,\chi_c,v_c \gives f \tto \rho,\mu_f,\nil,v_f \\
    \rho,\mu_f,\nil,v_f \gives \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e, c, f, \t{false}) \tto \rho,\mu_w,\chi_w,v_w} \rule{While}{^{\t{false}}}\]

A loop continues normally if its condition is nonzero:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e \qquad v_e \ne 0 \\
    \rho,\mu_e,\nil,v_e \gives c \tto \rho_c,\mu_c,\chi_c,v_c \qquad \chi_c\not\in\{ \brk, \cnt \} \\
    \rho,\mu_c,\chi_c,v_c \gives f \tto \rho,\mu_f,\chi_f,v_f \\
    \rho,\mu_f,\chi_f,v_f \gives \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w} \rule{While}{^{\top,\t{true}}}\]

A flag skips the loop:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil \\
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e,c,f,\t{true}) \tto \rho,\mu_e,\chi_e,v_e} \rule{While}{^{\chi,\t{true}}}\]
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e,c,f,\t{false}) \tto \rho,\mu,\chi,v} \rule{While}{^{\chi,\t{false}}}\]

\cnt\ executes the finally clause before continuing as normal:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e \qquad v_e \ne 0 \\
    \rho,\mu_e,\nil,v_e \gives c \tto \rho_c,\mu_c,\cnt,v_c \\
    \rho,\mu_c,\nil,v_c \gives f \tto \rho,\mu_f,\chi_f,v_f \\
    \rho,\mu_f,\chi_f,v_f \gives \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w} \rule{While}{^{\cnt,\t{true}}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives c \tto \rho_c,\mu_c,\cnt,v_c \\
    \rho,\mu_c,\nil,v_c \gives f \tto \rho,\mu_f,\chi_f,v_f \\
    \rho,\mu_f,\chi_f,v_f \gives \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_w,\chi_w,v_w
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e, c, f, \t{false}) \tto \rho,\mu_w,\chi_w,v_w} \rule{While}{^{\cnt,\t{false}}}\]

\brk\ interrupts the loop but is not retransmitted:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e \qquad v_e \ne 0 \\
    \rho,\mu_e,\nil,v_e \gives c \tto \rho_c,\mu_c,\brk,v_c \\
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu_c,\nil,v_c} \rule{While}{^{\brk,\t{true}}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives c \tto \rho_c,\mu_c,\brk,v_c \\
\end{array}}{\rho,\mu,\chi,v \gives \t{CWHILE}(e, c, f, \t{false}) \tto \rho,\mu_c,\nil,v_c} \rule{While}{^{\brk,\t{false}}}\]

\subsection{Control flow}
\[\dfrac{
}{\rho,\mu,\nil,v \gives \t{CBREAK} \tto \rho,\mu,\brk,0} \rule{Break}{}\]
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{CBREAK} \tto \rho,\mu,\chi,v} \rule{Break}{^\chi}\]

\[\dfrac{
}{\rho,\mu,\nil,v \gives \t{CCONTINUE} \tto \rho,\mu,\cnt,0} \rule{Continue}{}\]
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{CCONTINUE} \tto \rho,\mu,\chi,v} \rule{Continue}{^\chi}\]

\[\dfrac{
}{\rho,\mu,\nil,v \gives \t{CRETURN}\ \t{None} \tto \rho,\mu,\ret,0} \rule{Return}{^\t{None}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e
\end{array}}{\rho,\mu,\nil,v \gives \t{CRETURN}(\t{Some}\ e) \tto \rho,\mu_e,\ret,v_e} \rule{Return}{^\t{Some}}\]

\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{CRETURN}\ \t{None} \tto \rho,\mu,\chi,v} \rule{Return}{^{\t{None}\chi}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
\end{array}}{\rho,\mu,\nil,v \gives \t{CRETURN}(\t{Some}\ e) \tto \rho,\mu_e,\chi_e,v_e} \rule{Return}{^{\t{Some}\chi}}\]

\subsection{Local variable declarations}

First, the obvious:
\[\dfrac{\begin{array}{c}
\end{array}}{\rho,\mu,\chi,v \gives \t{CLOCAL}\ [] \tto \rho,\mu,\chi,v} \rule{Local}{^0}\]
\[\dfrac{\begin{array}{c}
    \chi\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{CLOCAL}\ d \tto \rho,\mu,\chi,v} \rule{Local}{^\chi}\]

There are never functions defined in a \t{CLOCAL}, only \t{CDECL}:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e \\
    k \in alloc^8(\mu_e) \qquad \rho' = \rho[w \mapsto k] \qquad \mu' = \mu_e[k \mapsto v_e] \\
    \rho',\mu',\nil,v_e \gives \t{CLOCAL}\ S \tto \rho_s,\mu_s,\chi_s,v_s
\end{array}}{\rho,\mu,\chi,v \gives \t{CLOCAL}(\t{CDECL}(w,e)::S) \tto \rho_s,\mu_s,\chi_s,v_s} \rule{Local}{^1}\]

\subsection{Throw}
If a flag is already raised, skip the \t{CTHROW}:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{CTHROW}(s,e) \tto \rho,\mu_e,\chi_e,v_e} \rule{Throw}{^\chi}\]

Otherwise raise the new exception \(s\in S\):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e
\end{array}}{\rho,\mu,\chi,v \gives \t{CTHROW}(s,e) \tto \rho,\mu_e,s,v_e} \rule{Throw}{}\]

\subsection{Switch}

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \qquad \chi\ne\nil
\end{array}{c}}{\rho,\mu,\chi,v \gives \t{CSWITCH}(e, L, c) \tto \rho,\mu_e,\chi_e,v_e} \rule{Switch}{^\chi}\]


\end{document}
