\input{header.tex}

\newcommand{\Cmp}{\(\pm\)C}
\newcommand{\Cmm}{C\textminus\textminus}
\newcommand{\fun}{\text{fun}_\pi^n}
\newcommand{\fnptr}{\text{fun}_\mu^n}
\newcommand{\gives}{\vdash_\pi}
\newcommand{\brk}{\t{brk}}
\newcommand{\ret}{\t{ret}}
\newcommand{\cnt}{\t{cnt}}
\newcommand{\nil}{\t{nil}}

\title{Semantics of \Cmp (i.e. extended \Cmm)}
\author{\textsc{Villani} Neven, ENS Paris-Saclay\\\textsc{Programmation 1 -- Compilateur COCass}}

\begin{document}
\maketitle

Retranscribed and extended from \url{http://www.lsv.fr/~goubault/CoursProgrammation/minic.html}\\
and \url{http://www.lsv.fr/~goubault/CoursProgrammation/prog1_sem1.pdf}.\\


\section{Expressions}

\subsection*{Notation}

\(\ZZ_{64}\) is the set of 64-bit signed integers, in which all calculations are done when not specified otherwise.\\

We write \((\rho: \mathcal{S}\to\ZZ_{64})\in \mathcal{P}\) the environment, where \(\mathcal{S}\) is the set of names of variables and functions, \((\mu: \ZZ_{64}\to\ZZ_{8})\in \mathcal{M}\) the memory.\\
\(\mu\) is read by blocks of 8 bytes : \(\mu^{64}(i) \triangleq \sum_{k=0}^7 2^{8k}\mu(i+k)\).\\
\(\rho_g\in\mathcal{P}\) is the global environment.\\

A flag is defined as an element of \(\mathcal{E} \triangleq S \sqcup \{ \brk, \ret, \cnt, \nil \}\): either an exception string or a special control flow keyword.\\
Intuitively, \(\rho,\mu,\chi,v \gives c \tto \rho',\mu',\chi',v'\) means that when \(c\) is executed under the environment \(\rho\) with the memory \(\mu\), the flag \(\chi\), and the previous value \(v\), it updates it to the new environment and memory \(\rho'\) and \(\mu'\), raises \(\chi'\), and changes the value to \(v'\).\\

In addition, we write \(\fun: \ZZ_{64}\to \t{code}\), a wrapper around \Cmp\ functions: \(\fun(a)(p_1, \cdots, p_n) = c\) updates the environment with \(p_1, \cdots, p_n\) and executes the body of the function whose definition was given by the code \(c\) and stored at \(a\). This way of considering functions allows in particular for function pointers.\\

For \(\mu\in\mathcal{M}, v\in\ZZ_{8}, x\in\ZZ_{64}\) we write \(\mu[x\mapsto v]: \left\{\begin{array}{ll}x\mapsto v & \\ y\mapsto \mu(y) & y\in \dom\mu\setminus\{x\}\end{array}\right.\)\\
However we will usually use \(\mu^{64}[x\mapsto v] \triangleq\mu[x+k\mapsto v_k\ |\  0\leq k<8,\ v = \sum_{k=0}^8 2^{8k}v_k]\), i.e. the memory is written 8 bytes at a time.\\

A similar notation is used for \(\rho\), \(\rho_g\) and \(\fun\).

\subsection{Reading values}
For local and global variables:
\[\dfrac{x\in\dom\rho \qquad \rho(x)\in\dom\mu}{\rho,\mu,\nil,v \gives \t{VAR}\ x\tto \rho,\mu,\nil,\mu^{64}(\rho(x))}\rule{Var}{}\]
i.e. reading a variable returns its contents and changes nothing to the memory.\\
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives \t{VAR}\ x\tto \rho,\mu,\chi,v} \rule{Var}{^\chi}\]

For constant integers:
\[\dfrac{}{\rho,\mu,\nil,v \gives \t{CST}\ n\tto \rho,\mu,\nil,n}\rule{Cst}{}\]
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives \t{CST}\ n\tto \rho,\mu,\chi,v} \rule{Cst}{^\chi}\]

For strings:
\[\dfrac{s\text{ stored at }a\in Addr}{\rho,\mu,\nil,v \gives \t{STRING}\ s\tto \rho,\mu,\nil,a}\rule{Str}{}\]
\[\dfrac{\chi\ne\nil}{\rho,\mu,\chi,v \gives \t{STRING}\ s\tto \rho,\mu,\chi,v} \rule{Cst}{^\chi}\]

For arrays:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,i \gives a\tto \rho,\mu_a,\nil,v_a \\
    v_a+v_i\times 8\in\dom\mu_a
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_INDEX}, a, i) \tto \rho,\mu_a,\nil,\mu_a^{64}(v_a+v_i\times 8)}\rule{Idx}{}\]

None of these are different from the original \Cmm\ semantics.

\subsection{Unary operators without side-effects}
Unary minus (same as \Cmm):
\[\dfrac{
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\nil,v_e
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_MINUS}, e) \tto \rho,\mu_e,\nil,-v_e}\rule{Neg}{}\]

Unary bitwise negation (same as \Cmm):
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\nil,v_e
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_NOT}, e) \tto \rho,\mu_e,\nil,-v_e-1}\rule{Not}{}\]


Indirection (added in \Cmp):
\[\dfrac{
    x\in\dom\rho
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_ADDR}, \t{VAR}\ x)\tto \rho,\mu,\nil,\rho(x)}\rule{Var}{^\&}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu_a,\nil,v_a \\
\end{array}}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_ADDR}, \t{OP2}(\t{S\_INDEX}, a, i)) \tto \rho,\mu_a,\nil,v_a+v_i\times 8}\rule{Idx}{^\&}\]

\[\dfrac{
    \rho,\mu,\chi,v \gives a \tto \rho,\mu_a,\nil,v_a
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_ADDR}, \t{OP1}(\t{M\_DEREF}, a)) \tto \rho,\mu_a,\nil,v_a}\rule{Ptr}{^\&}\]

Dereferencing (added in \Cmp):
\[\dfrac{
    \rho,\mu,\chi,v \gives a\tto \rho,\mu_a,\nil,v_a \qquad v_a\in\dom\mu_a
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_DEREF}, a) \tto \rho,\mu_a,\nil,\mu_a^{64}(v_a)}\rule{Ptr}{}\]

When the operand raises a non-\nil\ flag:
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \qquad \chi_e\ne\nil
}{\rho,\mu,\chi,v \gives \t{OP1}(op, e) \tto \rho,\mu_e,\chi_e,v_e}\rule{Op1}{^\chi}\]

\subsection{Binary operators}
Multiplication (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_MUL}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\times v_2}\rule{Mul}{}\]

Addition (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_ADD}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1 + v_2}\rule{Add}{}\]

Subtraction (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_SUB}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1 - v_2}\rule{Sub}{}\]

Division and remainder (same as \Cmm):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad v_2\ne 0\\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_DIV}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\div v_2}\rule{Div}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad v_2\ne 0\\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_MOD}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\mod v_2}\rule{Mod}{}\]

Shifts (added in \Cmp):
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_SHL}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\times 2^{v_2}}\rule{Shl}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_SHR}, e_1, e_2) \tto \rho,\mu_1,\nil,v_1\div 2^{v_2}} \rule{Shr}{}\]

Let \(\dec: \{ \bot, \top \}^{64} \to \ZZ_{64}\) the function
\[(b_0, \cdots, b_{63}) \mapsto \sum_{i=0}^{63} (1\t{ if } b_i\t{ else }0)\times 2^i\]
and \(\bin = \dec^{-1}\).

We can now define bitwise operators as follows (added in \Cmp).\\
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_AND}, e_1, e_2) \tto \rho,\mu_1,\nil,\dec(b_0^1 \wedge b_0^2,\cdots, b_{63}^1 \wedge b_{63}^2),\mu_1} \rule{And}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_OR}, e_1, e_2) \tto \rho,\mu_1,\nil,\dec(b_0^1 \vee b_0^2,\cdots, b_{63}^1 \vee b_{63}^2),\mu_1} \rule{Ior}{}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \qquad \rho,\mu_2,\chi_2,v_2\gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    (b_0^2,\cdots,b_{63}^2) = \bin(v_2) \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1)
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(\t{S\_XOR}, e_1, e_2) \tto \rho,\mu_1,\nil,\dec(b_0^1 \oplus b_0^2,\cdots, b_{63}^1 \oplus b_{63}^2),\mu_1} \rule{Xor}{}\]

When one of the operands raises a non-\nil\ flag:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\chi_1,v_1 \\
    \chi_1\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{OP2}(op, e_1, e_2) \tto \rho,\mu_1,\chi_1,v_1} \rule{Op2}{^\chi}\]

\subsection{Comparisons}
All are the same as in \Cmm.
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 = v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_EQ}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Eq}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 < v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_LT}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Lt}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \leq v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_LE}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Le}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \ne v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_EQ}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Eq}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \not< v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_LT}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Lt}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \not\leq v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_LE}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Le}{^\bot}\]

For optimisation purposes mostly, the comparison operators \(\t{C\_NE}\), \(\t{C\_GT}\), \(\t{C\_GE}\) may be introduced by the compiler (not by the parser, however).\\
They are defined as
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 = v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_NE}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Ne}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \leq v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_GT}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Gt}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 < v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_GE}, e_1, e_2) \tto \rho,\mu_1,\nil,0}\rule{Ge}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \ne v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_NE}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Ne}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \not\leq v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_GT}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Gt}{^\top}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\nil,v_1 \\
    \qquad v_1 \not< v_2
\end{array}}{\rho,\mu,\nil,v \gives \t{CMP}(\t{C\_GE}, e_1, e_2) \tto \rho,\mu_1,\nil,1}\rule{Ge}{^\top}\]

When one of the operands raises a non-\nil\ flag:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e_2\tto \rho,\mu_2,\chi_2,v_2 \\
    \rho,\mu_2,\chi_2,v_2 \gives e_1\tto \rho,\mu_1,\chi_1,v_1 \\
    \chi_1\ne\nil
\end{array}}{\rho,\mu,\chi,v \gives \t{CMP}(op, e_1, e_2) \tto \rho,\mu_1,\chi_1,v_1} \rule{Cmp}{^\chi}\]

\subsection{Assignments}

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu',\t{nil},v_e \\
    x\in\dom\rho \qquad \rho(x)\in\dom\mu'
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_VAR}(x, e) \tto \rho,\mu'[\rho(x)\mapsto v_e],\t{nil},v_e}\rule{Var}{^\gets}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu',\chi',v_e \qquad \chi'\ne\t{nil}
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_VAR}(x, e) \tto \rho,\mu',\chi',v_e}\rule{Var}{^{\gets\chi}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives i\tto \rho,\mu',\t{nil},v_i \\
    \rho(x)\in\dom\mu'
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_ARRAY}(x, i, e) \tto \rho,\mu'[\rho(x)+v_i\times 8 \mapsto v_e],\t{nil},v_e}\rule{Idx}{^\gets}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e\tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives i\tto \rho,\mu',\chi',v_i \qquad \chi'\ne\t{nil}
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_ARRAY}(x, i, e) \tto \rho,\mu',\chi',v_i}\rule{Idx}{^{\gets\chi}}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives a \tto \rho,\mu',\t{nil},v_a
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_DEREF}(a, e) \tto \rho,\mu'[v_a\mapsto v_e],\t{nil},v_e}\rule{Ptr}{^\gets}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\chi,v \gives e \tto \rho,\mu_e,\chi_e,v_e \\
    \rho,\mu_e,\chi_e,v_e \gives a \tto \rho,\mu',\chi',v_a \qquad \chi'\ne\t{nil}
\end{array}}{\rho,\mu,\chi,v \gives \t{SET\_DEREF}(a, e) \tto \rho,\mu',\chi',v_a}\rule{Ptr}{^{\gets\chi}}\]

\subsection{Increments}
On variables:
\[\dfrac{
    x\in\dom\rho \qquad \rho(x) = k \in\dom\mu
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_POST\_INC}, \t{VAR}\ x) \tto \rho,\mu[k\mapsto \mu(k)+1],\t{nil},\mu(k)} \rule{Var}{^{\bullet\uparrow}}\]
\[\dfrac{
    x\in\dom\rho \qquad \rho(x) = k \in\dom\mu
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_POST\_DEC}, \t{VAR}\ x) \tto \rho,\mu[k\mapsto \mu(k)-1],\t{nil},\mu(k)} \rule{Var}{^{\bullet\downarrow}}\]
\[\dfrac{
    x\in\dom\rho \qquad \rho(x) = k \in\dom\mu \qquad \mu(k)+1 = v_k
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_PRE\_INC}, \t{VAR}\ x) \tto \rho,\mu[k\mapsto v_k],\t{nil},v_k} \rule{Var}{^{\uparrow \bullet}}\]
\[\dfrac{
    x\in\dom\rho \qquad \rho(x) = k \in\dom\mu \qquad \mu(k)-1 = v_k
}{\rho,\mu,\nil,v \gives \t{OP1}(\t{M\_PRE\_DEC}, \t{VAR}\ x) \tto \rho,\mu[k\mapsto v_k],\t{nil},v_k} \rule{Var}{^{\downarrow \bullet}}\]

%%%%% HERE FOR UPDATE v,mu -> rho,mu,chi,v
On arrays:
\[\dfrac{
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu',\t{nil},v_a \qquad v_a+v_i\times8 = k \qquad k\in\dom\mu'
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_POST\_INC}, \t{OP2}(\t{S\_INDEX}, a, e)) \tto \rho,\mu''[k \mapsto \mu''(k)+1],\t{nil},\mu'(k)}\rule{Idx}{^{\bullet\uparrow}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu',\t{nil},v_a \qquad v_a+v_i\times8 = k \qquad k\in\dom\mu'
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_POST\_DEC}, \t{OP2}(\t{S\_INDEX}, a, e)) \tto \rho,\mu''[k \mapsto \mu''(k)-1],\t{nil},\mu'(k)}\rule{Idx}{^{\bullet\downarrow}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu',\t{nil},v_a \qquad v_a+v_i\times8 = k \qquad k\in\dom\mu' \qquad \mu''(k)+1 = k'
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_PRE\_INC}, \t{OP2}(\t{S\_INDEX}, a, e)) \tto \rho,\mu'[k \mapsto v],\t{nil},k'}\rule{Idx}{^{\uparrow \bullet}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives i\tto \rho,\mu_i,\chi_i,v_i \\
    \rho,\mu_i,\chi_i,v_i \gives a\tto \rho,\mu',\t{nil},v_a \qquad v_a+v_i\times8 = k \qquad k\in\dom\mu' \qquad \mu''(k)-1 = k'
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_PRE\_DEC}, \t{OP2}(\t{S\_INDEX}, a, e)) \tto \rho,\mu'[k \mapsto v],\t{nil},k'}\rule{Idx}{^{\downarrow \bullet}}\]

On dereferences:
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu',\t{nil},k
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_POST\_INC}, \t{OP1}(\t{M\_DEREF}, e) \tto \rhox,\mu'[k\mapsto \mu'(k)+1],\t{nil},\mu'(k)} \rule{Ptr}{^{\bullet\uparrow}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu',\t{nil},k
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_POST\_DEC}, \t{OP1}(\t{M\_DEREF}, e) \tto \rho,\mu'[k\mapsto \mu'(k)-1],\t{nil},\mu'(k)} \rule{Ptr}{^{\bullet\downarrow}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu',\t{nil},k \qquad \mu'(k)+1 = k'
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_PRE\_INC}, \t{OP1}(\t{M\_DEREF}, e) \tto \rho,\mu'[k\mapsto v],\t{nil},k'} \rule{Ptr}{^{\uparrow \bullet}}\]
\[\dfrac{
    \rho,\mu,\chi,v \gives e\tto \rho,\mu',\t{nil},k \qquad \mu'(k)-1 = k'
}{\rho,\mu,\chi,v \gives \t{OP1}(\t{M\_PRE\_DEC}, \t{OP1}(\t{M\_DEREF}, e) \tto \rho,\mu'[k\mapsto v],\t{nil},k'} \rule{Ptr}{^{\downarrow \bullet}}\]

\subsection{Extended assignments}
Let \(op\in \t{bin\_op}\setminus \{ \t{S\_INDEX} \}\).

On variables:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \gives e\tto v,\mu' \\
    x\in\dom\rho \qquad \rho(x)\in\dom(\mu') \qquad \rho(x) = k \qquad \mu'(k) = u \\
    \rho,\mu'\vdash_\pi\t{OP2}(op, \t{CST}\ v, \t{CST}\ u) \tto w,\mu''
\end{array}}{\rho,\mu,\t{nil},v \gives \t{OPSET\_VAR}(op, x, e) \tto w,\mu''[k\mapsto w]}\rule{Var}{^{\gets op}}\]

On arrays:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \gives e_2\tto v,\mu'\\
    \rho,\mu'\vdash_\pi e_1\tto i,\mu''\\
    t\in\dom\rho \qquad \rho(t)+i\times8 = k \qquad k\in\dom\mu''\\
    \mu''(k) = u \qquad \rho,\mu''\vdash_\pi\t{OP2}(op, \t{CST}\ v, \t{CST}\ u) \tto w\mu'''
\end{array}}{\rho,\mu,\t{nil},v \gives \t{OPSET\_ARRAY}(op, t, e_1, e_2) \tto w,\mu'''[k\mapsto w]}\rule{Idx}{^{\gets op}}\]

On dereferences:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \gives e_2\tto v,\mu'\\
    \rho,\mu'\vdash_\pi e_1\tto k,\mu''\\
    k\in\dom\mu'' \qquad \mu''(k) = u \\
    \rho,\mu''\vdash_\pi\t{OP2}(op, \t{CST}\ v, \t{CST}\ u) \tto w\mu'''
\end{array}}{\rho,\mu,\t{nil},v \gives \t{OPSET\_DEREF}(op, e_1, e_2) \tto w,\mu'''[k\mapsto w]}\rule{Ptr}{^{\gets op}}\]

\subsection{Ternary operator}
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \gives e\tto c,\mu' \qquad c = 0\\
    \rho,\mu'\vdash_\pi e_\bot \tto v,\mu''\\
\end{array}}{\rho,\mu,\t{nil},v \gives \t{EIF}(e, e_\top, e_\bot) \tto v,\mu''}\rule{Tern}{^\bot}\]

\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \gives e\tto c,\mu' \qquad c \ne 0\\
    \rho,\mu'\vdash_\pi e_\top \tto v,\mu''\\
\end{array}}{\rho,\mu,\t{nil},v \gives \t{EIF}(e, e_\top, e_\bot) \tto v,\mu''}\rule{Tern}{^\top}\]

\subsection{Sequence}
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \gives e_1 \tto v_1,\mu_1 \\
    \rho,\mu_1\vdash_\pi e_2 \tto v_2,\mu_2 \\
    \cdots \\
    \rho,\mu_{n-1}\vdash_\pi e_n \tto v_n,\mu' \\
\end{array}}{\rho,\mu,\t{nil},v \gives \t{ESEQ}\ [e_1;\cdots;e_n] \tto v_n,\mu'}\rule{Seq}{^n}\]
With a special case for the empty sequence:
\[\dfrac{}{\rho,\mu,\t{nil},v \gives \t{ESEQ}\ [] \tto x,\mu}\rule{Seq}{^0}\]
where \(x\) is an arbitrary value

\subsection{Function call}
For a toplevel function:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \gives e_n \tto v_n,\mu_n \\
    \rho,\mu_n\vdash_\pi e_{n-1} \tto v_{n-1},\mu_{n-1} \\
    \cdots \\
    \rho,\mu_2\vdash_\pi e_1 \tto v_1,\mu' \\
    f\in\dom\fun\setminus\dom\rho \qquad \fun(f)(\rho, \mu', v_1, \cdots, v_n) = (w, \mu'')
\end{array}}{\rho,\mu,\t{nil},v \gives \t{CALL}(f, [e_1; \cdots; e_n]) \tto w,\mu''}\rule{Call}{_\pi^n}\]

For a function pointer:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \gives e_n \tto v_n,\mu_n \\
    \rho,\mu_n\vdash_\pi e_{n-1} \tto v_{n-1},\mu_{n-1} \\
    \cdots \\
    \rho,\mu_2\vdash_\pi e_1 \tto v_1,\mu' \\
    f\in\dom\rho \qquad \rho(f)\in\dom\fnptr \qquad \fnptr(\rho(f))(\rho, \mu', v_1, \cdots, v_n) = (w,\mu'')
\end{array}}{\rho,\mu,\t{nil},v \gives \t{CALL}(f, [e_1; \cdots; e_n]) \tto w,\mu''}\rule{Call}{_\mu^n}\]



\section{Code}
\subsection{Expressions}
When an expression is executed as a statement.\\
If only the flag \t{nil} is raised, the expression is executed
\[\dfrac{
    \rho,\mu \vdash_\pi e \tto v',\mu'
}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CEXPR}\ e \tto \rho,\mu',\t{nil},v'}\rule{Expr}{^\t{nil}}\]

Otherwise it is skipped.
\[\dfrac{\chi\ne\t{nil}}{\rho,\mu,\chi,v \Vdash_\pi \t{CEXPR}\ e\tto \rho,\mu,\chi,v}\rule{Expr}{^\chi}\]

\subsection{Conditional branching}
If only \t{nil} is raised, one of the two branches is executed depending on how the condition evaluates.
\[\dfrac{\begin{array}{c}
    \rho,\mu \vdash_\pi e \tto v,\mu' \qquad v = 0 \\
    \rho,\mu',\t{nil},v \Vdash_\pi c_\bot \tto \rho',\mu',x,v' \\
\end{array}}{\rho,\mu',\t{nil},v \Vdash_\pi \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu',x,v'}\rule{If}{^\bot}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu \vdash_\pi e \tto v,\mu' \qquad v \ne 0 \\
    \rho,\mu',\t{nil},v \Vdash_\pi c_\top \tto \rho',\mu',x,v' \\
\end{array}}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu',x,v'}\rule{If}{^\top}\]
Note that the branch is allowed to modify the memory and raise flags, but not change the environment: \(\rho\) is preserved.\\

For all other flags, the condition and both branches are skipped.
\[\dfrac{\chi\ne\t{nil}}{\rho,\mu,\chi,v \Vdash_\pi \t{CIF}(e, c_\top, c_\bot) \tto \rho,\mu,\chi,v}\rule{If}{^\chi}\]

\subsection{Blocks}
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \Vdash_\pi c \tto \rho',\mu',\chi',v' \\
    \rho',\mu',\chi',v' \Vdash_\pi \t{CBLOCK}\ S \tto \rho'',\mu'',\chi'',v''
\end{array}}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CBLOCK}(c :: S) \tto \rho,\mu'',\chi'',v''} \rule{Block}{^1}\]
\[\dfrac{}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CBLOCK}\ [] \tto \rho,\mu,\t{nil},v''} \rule{Block}{^0}\]
Again for blocks, the memory may be changed and flags may be raised, but the environment is preserved.\\

For all other flags, the whole block is skipped.
\[\dfrac{\chi\ne\t{nil}}{\rho,\mu,\chi,v \Vdash_\pi \t{CBLOCK}\ S \tto \rho,\mu,\chi,v} \rule{Block}{^\chi}\]

\subsection{Loops}
A loop with a false condition stops:
\[\dfrac{\begin{array}{c}
    \rho,\mu \vdash_\pi e \tto a,\mu' \qquad a = 0 \\
\end{array}}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CWHILE}(e, c, f, \t{true}) \tto \rho,\mu',\t{nil},v} \rule{While}{^{\bot,f,\t{true}}}\]
Except in the case of a \t{do-while}:
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \Vdash_\pi c \tto \rho',\mu',\t{nil},v' \\
    \rho,\mu',\t{nil},v' \Vdash_\pi \t{CWHILE}(e, c, \t{None}, \t{true}) \tto \rho'',\mu'',\chi'',v''
\end{array}}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CWHILE}(e, c, \t{None}, \t{false}) \tto \rho,\mu'',\chi'',v''}\rule{While}{^{\top,\t{None},\t{false}}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu,\t{nil},v \Vdash_\pi c \tto \rho',\mu',\t{nil},v' \\
    \rho,\mu' \vdash_\pi f \tto a,\mu'' \\
    \rho,\mu'',\t{nil},v' \Vdash_\pi \t{CWHILE}(e, c, \t{Some}\ f, \t{true}) \tto \rho''',\mu''',\chi''',v'''
\end{array}}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CWHILE}(e, c, \t{Some}\ f, \t{false}) \tto \rho,\mu''',\chi''',v'''}\rule{While}{^{\top,\t{Some},\t{false}}}\]


A loop continues normally if its condition is nonzero and its body does not raise a flag other than \t{nil}:
\[\dfrac{\begin{array}{c}
    \rho,\mu \vdash_\pi e \tto a,\mu' \qquad a \ne 0 \\
    \rho,\mu',\t{nil},v' \Vdash_\pi c \tto \rho'',\mu'',\t{nil},v'' \\
    \rho,\mu'',\t{nil},v'' \Vdash_\pi \t{CWHILE}(e, c, \t{None}, \t{true}) \tto \rho''',\mu''',\chi''',v'''
\end{array}}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CWHILE}(e, c, \t{None}, \t{true}) \tto \rho,\mu''',\chi''',v'''}\rule{While}{^{\top,\t{None},\t{true}}}\]
\[\dfrac{\begin{array}{c}
    \rho,\mu \vdash_\pi e \tto a,\mu' \qquad a \ne 0 \\
    \rho,\mu',\t{nil},v' \Vdash_\pi c \tto \rho'',\mu'',\t{nil},v'' \\
    \rho,\mu'' \vdash_\pi f \tto \rho''',\mu''' \\
    \rho,\mu''',\t{nil},v''' \Vdash_\pi \t{CWHILE}(e, c, \t{Some}\ f, \t{true}) \tto \rho'''',\mu'''',\chi'''',v''''
\end{array}}{\rho,\mu,\t{nil},v \Vdash_\pi \t{CWHILE}(e, c, \t{Some}\ f, \t{true}) \tto \rho,\mu'''',\chi'''',v''''}\rule{While}{^{\top,\t{Some},\t{true}}}\]

\end{document}
