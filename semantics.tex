\input{header.tex}

\newcommand{\Cpm}{C\(\pm\pm\)}
\newcommand{\Cmm}{C\textminus\textminus}

\title{Semantics of \Cpm (i.e. extended \Cmm)}
\author{\textsc{Villani} Neven, ENS Paris-Saclay\\\textsc{Programmation 1 -- Compilateur COCass}}

\begin{document}
\maketitle

Retranscribed and extended from \url{http://www.lsv.fr/~goubault/CoursProgrammation/minic.html}\\
and \url{http://www.lsv.fr/~goubault/CoursProgrammation/prog1_sem1.pdf}.\\

Let \(\rho\) be the environment, \(\mu\) the function that gives the contents of each memory address.\\

\section{Expressions}
\subsection{Reading values}

For local and global variables:
\[\dfrac{x\in\dom\rho \qquad \rho(x)\in\dom\mu}{\envyields \t{VAR}\ x\tto \mu(\rho(x)), \mu}\]
i.e. reading a variable returns its contents and changes nothing to the memory.\\

For constant integers:
\[\dfrac{}{\envyields \t{CST}\ n\tto n, \mu}\]

For strings:
\[\dfrac{s\text{ stored at }a\in Addr}{\envyields \t{STRING}\ s\tto a, \mu}\]

For arrays:
\[\dfrac{t\in\dom\rho \qquad \envyields e\tto i,\mu' \qquad (\rho(t)+i\times 8)\modsize\in\dom\mu}{\envyields \t{OP2}(\t{S\_INDEX}, t, e) \tto \mu'(\rho(t)+i\times 8 \modsize)}\]

None of these are different from the original \Cmm semantics.

\subsection{Unary operators without side-effects}
Unary minus (same as \Cmm):
\[\dfrac{\envyields e \tto v,\mu'}{\envyields \t{OP1}(\t{M\_MINUS}, e) \tto -v \modsize,\mu'}\]

Unary bitwise negation (same as \Cmm):
\[\dfrac{\envyields e\tto v,\mu'}{\envyields \t{OP1}(\t{M\_NOT}, e) \tto -v-1 \modsize,\mu'}\]

Indirection (added in \Cpm):
\[\dfrac{x\in\dom\rho}{\envyields \t{OP1}(\t{M\_ADDR}, x)\tto \rho(x),\mu}\]
\[\dfrac{x\in\dom\rho \qquad \envyields e\tto v,\mu'}{\envyields \t{OP1}(\t{M\_ADDR}, \t{OP2}(\t{S\_INDEX}, x, e)) \tto (\rho(x)+v\times 8) \modsize, \mu'}\]
\[\dfrac{\envyields e\tto v,\mu'}{\envyields \t{OP1}(\t{M\_ADDR}, \t{OP1}(\t{M\_DEREF}, e)) \tto v,\mu'}\]

Dereferencing (added in \Cpm):
\[\dfrac{\envyields e\tto v,\mu' \qquad v\in\dom\mu'}{\envyields \t{OP1}(\t{M\_DEREF}, e) \tto \mu'(v),\mu'}\]

\subsection{Binary operators without side-effects}
Multiplication (same as \Cmm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_MUL}, e_1, e_2) \tto v_1\times v_2\modsize,\mu''}\]

Addition (same as \Cmm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_ADD}, e_1, e_2) \tto v_1 + v_2\modsize,\mu''}\]

Subtraction (same as \Cmm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_SUB}, e_1, e_2) \tto v_1 - v_2\modsize,\mu''}\]

Division and remainder (same as \Cmm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_DIV}, e_1, e_2) \tto v_1 \div v_2,\mu''}\]
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_MOD}, e_1, e_2) \tto v_1 \mod v_2,\mu''}\]
Since \(v_1 \div v_2\) and \(v_1 \mod v_2\) are sure to be in the correct range, there is no need to specify they are taken \(\modsize\).

Shifts (added in \Cpm):
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_SHL}, e_1, e_2) \tto v_1 \times 2^{v_2} \modsize}\]
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu''}{\envyields \t{OP2}(\t{S\_SHL}, e_1, e_2) \tto v_1 \div 2^{v_2} \modsize}\]



Let \(\dec: \{ \bot, \top \}^{64} \to \ZZ_{64}\) the function
\[(b_0, \cdots, b_{63}) \mapsto \sum_{i=0}^{63} (1\t{ if } b_i\t{ else }0)\times 2^i\]
and \(\bin = \dec^{-1}\).

We can now define bitwise operators as follows (added in \Cpm).\\
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu'' \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1) \qquad (b_0^2,\cdots,b_{63}^2) = \bin(v_2)}{\envyields \t{OP2}(\t{S\_AND}, e_1, e_2) \tto \dec(b_0^1 \wedge b_0^2,\cdots, b_{63}^1 \wedge b_{63}^2)}\]
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu'' \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1) \qquad (b_0^2,\cdots,b_{63}^2) = \bin(v_2)}{\envyields \t{OP2}(\t{S\_OR}, e_1, e_2) \tto \dec(b_0^1 \vee b_0^2,\cdots, b_{63}^1 \vee b_{63}^2)}\]
\[\dfrac{\envyields e_2\tto v_2,\mu' \qquad \mu',\rho\vdash_\pi e_1\tto v_1,\mu'' \qquad (b_0^1,\cdots,b_{63}^1) = \bin(v_1) \qquad (b_0^2,\cdots,b_{63}^2) = \bin(v_2)}{\envyields \t{OP2}(\t{S\_XOR}, e_1, e_2) \tto \dec(b_0^1 \oplus b_0^2,\cdots, b_{63}^1 \oplus b_{63}^2)}\]


\end{document}
