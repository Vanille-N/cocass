\section{Additions}

The following constructs were added to the supported language:

\subsection{Unary operators}
\t{M\_DEREF}: accesses the address given by the expression.\\
Examples:
\begin{itemize}
    \item \t{*x} \to\ \ml{OP1(M_DEREF, VAR "x")}
    \item \t{*(x+1)} \to\ \ml{OP1(M_DEREF, OP2(S_ADD, VAR "x", CST 1))}
\end{itemize}

\t{M\_ADDR}: yields the address of an expression\\
Examples
\begin{itemize}
    \item \t{\&x} \to\ \ml{OP1(M_ADDR, VAR "x")}
    \item \t{\&x[10]} \to\ \ml{OP1(M_ADDR, OP2(M_INDEX, VAR "x", CST 10))}
    \item \t{\&*x} \to\ \ml{OP1(M_ADDR, OP1(M_DEREF, VAR "x"))}
\end{itemize}
Errors
\begin{itemize}
    \item \t{\&10}, \t{\&(x+1)}, \t{\&"abc"} \to\ `Indirection needs an lvalue'
\end{itemize}

Note:
\begin{itemize}
    \item \forall \t{e}, \ml{OP1(M_ADDR, OP1(M_DEREF, e))} is equivalent to \t{e}
    \item \forall \t{e} with an address, \ml{OP1(M_DEREF, OP1(M_ADDR, e))} is equivalent to \t{e}
\end{itemize}


\subsection{Binary operators}
The following binary operators were added:
\t{S\_SHL}, \t{S\_SHR}, \t{S\_OR}, \t{S\_XOR}, \t{S\_AND}
Examples
\begin{itemize}
    \item \t{x << 2} \to\ \ml{OP2(S_SHL, VAR "x", CST 2)}
    \item \t{x >> 2} \to\ \ml{OP2(S_SHR, VAR "x", CST 2)}
    \item \t{x | 2} \to\ \ml{OP2(S_OR, VAR "x", CST 2)}
    \item \t{x \textasciicircum\ 2} \to\ \ml{OP2(S_XOR, VAR "x", CST 2)}
    \item \t{x \& 2} \to\ \ml{OP2(S_AND, VAR "x", CST 2)}
\end{itemize}

\subsection{Comparisons}
To simplify some expressions, the reduction step is allowed to perform the following transformations.\\
For any \t{a}, \t{b}:
\begin{itemize}
    \item \ml{EIF(CMP(C_EQ, a, b), 0, 1)} \to\ \ml{CMP(C_NE, a, b)}
    \item \ml{EIF(CMP(C_LE, a, b), 0, 1)} \to\ \ml{CMP(C_GT, a, b)}
    \item \ml{EIF(CMP(C_LT, a, b), 0, 1)} \to\ \ml{CMP(C_GE, a, b)}
\end{itemize}

\subsection{Extended assignment}
Examples
\begin{itemize}
    \item \t{x += 2} \to\ \ml{OPSET(M_ADD, VAR "x", CST 2)}
    \item \t{x *= 2} \to\ \ml{OPSET(M_MUL, VAR "x", CST 2)}
    \item etc...
\end{itemize}
Errors
\begin{itemize}
    \item \t{x []= 2} \to\ parsing error
    \item \t{2 += 2} \to\ `Extended assignment needs an lvalue'
\end{itemize}

\subsection{Control flow}
\t{CBREAK} (exit loop or switch), \t{CCONTINUE} (skip to next iteration of loop), \t{CTHROW} (raise exception)\\
Examples
\begin{itemize}
    \item \t{break;} \to\ \ml{CBREAK}
    \item \t{continue;} \to\ \ml{CCONTINUE}
    \item \t{throw E(x);} \to\ \ml{CTHROW("E", VAR "x")}
    \item \t{throw E;} \to\ \ml{CTHROW("E", VAR "NULL")}
\end{itemize}
Errors
\begin{itemize}
    \item \t{try \{ break; \}} \to\ `break may not reach outside of try'
    \item \t{try \{ continue; \}} \to\ `continue may not reach outside of try'
\end{itemize}

\subsection{Declarations}
\t{CLOCAL} is used to declare a local variable in the middle of a block.
Examples
\begin{itemize}
    \item \t{int x;} \to\ \ml{CLOCAL[("x", None)]}
    \item \t{int x, y;} \to\ \ml{CLOCAL[("x", None), ("y", None)]}
    \item \t{int x = 1;} \to\ \ml{CLOCAL[("x", Some (CST 1))]}
\end{itemize}
